 Step 1: Refactor TokenHelper

  First, let's make TokenHelper more DI-friendly. We'll create an interface for it and have it get its configuration via dependency injection
  instead of manual creation. We will also build the IConfidentialClientApplication object just once in the constructor.

    1 using Microsoft.Extensions.Options;
    2 using Microsoft.Identity.Client;
    3 using System.Threading.Tasks;
    4
    5 public interface ITokenHelper
    6 {
    7     Task<string> CreateJwtGraphAPITokenAsync();
    8 }
    9
   10 public class TokenHelper : ITokenHelper
   11 {
   12     private readonly IConfidentialClientApplication _app;
   13
   14     // Inject configuration using the standard IOptions pattern
   15     public TokenHelper(IOptions<GraphServiceClientWrapperSettings> configOptions)
   16     {
   17         var config = configOptions.Value;
   18         var authorityUrl = $"https://login.microsoftonline.com/{config.TenantId}";
   19
   20         _app = ConfidentialClientApplicationBuilder
   21             .Create(config.ClientId)
   22             .WithAuthority(authorityUrl)
   23             .WithClientSecret(config.ClientSecret)
   24             .Build();
   25     }
   26
   27     public async Task<string> CreateJwtGraphAPITokenAsync()
   28     {
   29         string[] scopes = { "https://graph.microsoft.com/.default" };
   30
   31         // MSAL is smart and will cache the token. It will only make a real
   32         // network call when the cached token is expired or not present.
   33         var authenticationResult = await _app.AcquireTokenForClient(scopes).ExecuteAsync();
   34
   35         return authenticationResult.AccessToken;
   36     }
   37 }

  Step 2: Refactor TokenProvider

  This is the most important change. Instead of holding a static token, this class will now use the TokenHelper to fetch a fresh token every
  time the Graph SDK asks for one.

    1 using Microsoft.Kiota.Abstractions.Authentication;
    2 using System;
    3 using System.Collections.Generic;
    4 using System.Threading;
    5 using System.Threading.Tasks;
    6
    7 public class TokenProvider : IAccessTokenProvider
    8 {
    9     private readonly ITokenHelper _tokenHelper;
   10
   11     // Inject the TokenHelper
   12     public TokenProvider(ITokenHelper tokenHelper)
   13     {
   14         _tokenHelper = tokenHelper;
   15     }
   16
   17     // This method is now "live". The Graph SDK will call it before every API request.
   18     public Task<string> GetAuthorizationTokenAsync(Uri uri, Dictionary<string, object>? additionalAuthenticationContext = null,
      CancellationToken cancellationToken = default)
   19     {
   20         // We delegate the call to our TokenHelper, which handles caching and refreshing.
   21         return _tokenHelper.CreateJwtGraphAPITokenAsync();
   22     }
   23
   24     public AllowedHostsValidator AllowedHostsValidator { get; } = new();
   25 }

  Step 3: Refactor Program.cs (The DI Setup)

  Now your DI setup becomes much cleaner and simpler. You just register each component, and the container connects them. There is no need for a
  complex factory with await calls.

    1 using Microsoft.Graph;
    2 using Microsoft.Kiota.Abstractions.Authentication;
    3 using Microsoft.Extensions.DependencyInjection;
    4 using Microsoft.Extensions.Configuration;
    5
    6 // (Assuming you have a GraphServiceClientWrapperSettings class for your config)
    7
    8 var builder = WebApplication.CreateBuilder(args);
    9
   10 // 1. Configure your settings using the options pattern.
   11 // This binds the values from appsettings.json and other config sources.
   12 builder.Services.AddOptions<GraphServiceClientWrapperSettings>()
   13     .Configure<IConfiguration>((settings, configuration) =>
   14     {
   15         // Assuming your settings are in a section named "GraphSvcClientWrapper"
   16         configuration.GetSection("GraphSvcClientWrapper").Bind(settings);
   17         // You can still get specific values from other places, like secrets.
   18         settings.ClientSecret = configuration["AzureAD:ClientSecret"];
   19     });
   20
   21 // 2. Register your refactored helper and provider as singletons.
   22 builder.Services.AddSingleton<ITokenHelper, TokenHelper>();
   23 builder.Services.AddSingleton<IAccessTokenProvider, TokenProvider>();
   24
   25 // 3. Register the Graph SDK's authentication provider.
   26 //    It will automatically get the IAccessTokenProvider from DI.
   27 builder.Services.AddSingleton<IAuthenticationProvider, BaseBearerTokenAuthenticationProvider>();
   28
   29 // 4. Finally, register the GraphServiceClient as a singleton.
   30 //    The DI container will automatically build it with the IAuthenticationProvider.
   31 builder.Services.AddSingleton<GraphServiceClient>();
   32
   33 // ... rest of your Program.cs
